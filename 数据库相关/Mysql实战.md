## Mysql实战

### 01|select语句的执行

客户端 -> 服务器层 -> 存储引擎

服务器层：

连接器 -> 分析器 -> 优化器 -> 执行器

#### **连接器**：权限验证

mysql -h$ip -P$port -u$user -p

* TCP握手
* 连接时读取用户权限 （权限修改后需要重新连接生效）

show processlist; 查看连接到数据库连接的状态 

Command->Sleep 表示空闲

wait_timeout 控制久置断开连接时间

使用数据库时 尽量减少连接动作的开销 -> 善用**长连接 **

（内存开销 ↑ 内存管理在连接对象中

① 定期断开长连接

② 执行 mysql_reset_connection

#### **分析器**：语法分析 词法分析

* 词法分析 ：识别SQL语句中的 关键字 | 表名 | 字段名 等等
* 语法分析 ：判断语法规则 此处报 error SQL syntax (第一个出现错误的地方)

#### **优化器**：选择索引

决定使用那个索引 | 决定各个表的连接顺序（JOIN）| 等等

#### **执行器**：执行语句 

以 SELECT 语句查询 InnoDB 引擎的数据库为例

① 查询权限 ；

② 调用InnoDB 引擎接口的表 逐行查询 根据逻辑 跳过 或 存取结果集；

③ 返回结果集；

-> 可以通过 ***慢查询日志* **中的 rows_examined 字段查看扫描了多少行

注： 有时调用一次执行器 或 扫描多行

#### **查询缓存**： 

在8.0版本以后功能删除     

key-value形式 

更新一次表就删除一次缓存 -> 存储不会发生变更的静态数据

query_cache_type = DEMAND 时，默认SQL语句均不使用查询缓存

### 02|update语句的执行

#### redo log：重做日志

记录该数据页做了什么改动

WAL ： writing-ahead logging 更新记录时 先记日志 （并更新内存）再写磁盘（InnoDB 空闲时）

如果 日志 写满 (InnoDB 特有的 引擎层日志 redo log大小是固定的)，MYSQL会突然降速 执行 写磁盘的操作

该日志可以保证 即使数据库异常重启 之前提交的记录都不会丢失 -> **crash-safe**

innodb_flush_log_at_trx_commit 参数设1 每次事务的redo log 持久至磁盘

#### binlog ：归档日志

Server层日志 所有引擎都可以使用

不同于redo log 是物理日志 binlog 是逻辑日志（原始sql语句），同时可以追加写，不需要覆盖从前的日志

sync_binlog 设1 每次事务持久至磁盘

#### update 语句

① 执行器找到引擎->搜索树->行所在数据页在内存 返回执行器

​                                               ->不在内存 从磁盘读入内存

② 执行器 执行操作 调用引擎接口写入数据

③ 引擎 更新内存 同时 更新redo log (prepare) -> 执行器可以提交事务

④ 执行器生成 binlog 写入磁盘

⑤ 执行器 调用引擎 提交事务；引擎redo log (commit) 更新

####  两阶段提交

保证两份日志的一致性 -> 保证数据库的一致性

**恢复库** 最近一次的备份->执行binlog

执行场景 ： 搭建备库（全量备份 + binlog）

***先写 redo log 数据库 crash 后写 binlog***

数据库异常重启 可以通过redo恢复 但通过binlog 备份 临时库与原库产生不同

***先写 binlog 数据库 crash 后写 redo log***

数据库异常重启 原库该事务无效 binlog已经记录 恢复的库与原库不一致

#### 全量备份周期

不同的备份周期带来的是不同的 目标恢复时间（RTO）

频繁的全量备份可以将最长恢复时间变短但需要消耗更多存储空间

### 03|事务隔离

事务支持在引擎层实现 、但并非所有引擎均支持事务

#### 隔离性与隔离级别

隔离越强 -> 效率越低

**读未提交** 事务尚未提交 更改可被看见

没有视图概念

**读提交** 事务提交后 才可被看到

视图在SQL语句执行时创建

**可重复读** 执行时与启动时数据保持一致

事务启动时 创建视图直至事务提交

一个使用场景：银行校对

**串行化** 等前一个事务执行完成才能进行下一个事务 写锁+读锁

加锁避免并行访问

数据库内创建视图 -> 根据视图逻辑结果为准

Oracle 默认 读提交

通过show variables 查看 、 设置 transactions-isolation = READ-COMMITTED

#### 事务隔离的实现

以 可重复读 为实例

MYSQL中每条更新记录都会记录一条回滚操作 -> 同一条记录在系统中可以存在多个版本（数据库**多版本并发控制**MVCC）

系统会自动删除回滚日志 -> 当系统没有事务在读该版本记录时

*尽量避免使用长事务*

① 系统存在非常旧的事务视图，会保留相当长的回滚记录，从而占用大量的存储空间

② 长事务占用锁资源

5.5版本前回滚日志和字典一起放于idbdata文件

*长事务的避免*

从开发端：① 通过 general_log 确认 autocommit 的状态；

​					② 确认是否有不必要的只读任务；

​					③ set MAX_EXECUTION_TIME 控制语句最大执行时间；

从库端：① 监控 informantion_schema.Innodb_trx 表，设置长事务阈值；

​				② Percona 的 pt-kill；

​				③ 业务功能测试时输出 general_log 分析日志行为；

​				④ 5.6版本以后 innodb_undo_tablespaces设置成 2，当大事务回滚段过大 清理时更方便。

#### 事务的启动

① 显示启动 BEGIN 或 START TRANSACTION 

提交 COMMIT 

回滚 ROLLBACK

② set autocommit = 0 会关闭自动提交功能 一直持续到执行COMMIT | ROLLBACK 或者 断开连接 （和有些客户端连接框架有关

在 information_schema 库的 innodb_trx中查询长事务

### 04|索引

索引 为了提高数据查询效率的数据结构

数据库的存储核心就是基于这些数据模型的

#### 常见模型

① **哈希表** key-val对 哈希冲突：拉链表，顺序遍历 

增加时很快 区间查找时很慢 -> 适用于等值查询

② **有序数组**  

等值|范围查询很快 新增成本太高 -> 适用于静态存储引擎（不会再修改的数据

③ **二叉搜索树**

左子树 < 根节点 < 右子树

维持复杂度O(log(N)) -> 平衡二叉树 -> 多叉树（索引不止在内存还在磁盘上）

对于MYSQL而言 一个节点长度为16K 一个整数字段的索引长度为8B 另外每个索引还有6B大小的指针指向子树，16K/14B = 1170 -> 1170叉树高4时可以存数十亿数据，大大减少了查磁盘的次数。此时N = 1170, 该N是可以调整的

<u>*拓展知识 跳表 LSM树 待补充*</u>

#### **InnoDB 索引**

B+ 树 配合磁盘读写特性 减少单次查询访问磁盘的次数

主键索引（聚簇索引）：叶子节点存放整行数据

非主键索引（二级索引）：叶子节点存放主键 （即查到主键再去查主键索引）

#### 索引维护

保持有序性  -> 存储过程中会发生叶子节点存储的数据页满需要申请新的数据页，导致页分裂影响性能和页的利用率（空间利用率降低50%）->通过合并解决分裂

建议 **自增主键** NOT NULL PRIMARY KEY AUTO_INCREMENT

原因：每次都是有序新插入 不涉及叶子节点的分裂（挪动其他数据

主键长度越小 普通索引叶子节点越小 普通索引所占空间越小（存放主键

*业务字段作主键：*

① 只有一个索引 ② 该索引唯一  -> K-V场景 -> 不存在其他索引

#### 覆盖索引

回到主键索引树搜索的过程称作 **回表**

覆盖索引可以减少树的搜索次数 显著提升查询性能 所以使用覆盖索引是一个常用的性能优化手段

会带来 冗余索引 的开销问题

#### 最左前缀原则

 B+ 树可以利用索引的最左前缀 定位记录

通过安排索引内的**字段顺序** 提高复用能力 减少维护索引数目 ： 以 （a , b）联合索引为例 无需单独再于 a 建立索引 

#### 索引下推

5.6版本后功能 根据查询到的信息在 回表 之前再次根据查询条件进行过滤（例如同时约束a b 5.6版本前查到a以后直接 回表） 从而减少回表次数

#### 重建索引

索引可能因为删除或者页分裂导致数据页有空洞，重建索引可以把数据按顺序插入，提高页面利用率，紧凑、省空间

但是主键的重建索引不建议使用

alter table T drop primary key;

alter table T add primary key(id);

而推荐使用

### 05|锁

#### 全局锁

FTWRL (命令 flush tables with read lock ) 令整个数据库处于可读状态

使用场景 **全库逻辑备份**

官方自带逻辑备份工具为 mysqldump 使用参数 single-transaction时 通过MVCC 备份过程中可以进行数据更新，但前提是引擎需要支持该隔离级别 即 所有表使用事务引擎的库 例如 InnoDB。

设置全库只读参数 set global readonly = true

① readonly 会被用于其他逻辑 比如判断 主库和从库

② 异常处理机制差异：客户端异常时 FTWRL 会释放全局锁 而  readonly 会使整个数据库处于 只读状态

※ 在备库上 single-transaction 备份 主库的binlog传来小表的DDL 备库会发生什么？

① 备份的关键流程 以表

Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；
/ other tables  /
Q3:SAVEPOINT sp;
/ 时刻 1 /
Q4:show create table `t1`;
/ 时刻 2 /
Q5:SELECT * FROM `t1`;
/ 时刻 3 /
Q6:ROLLBACK TO SAVEPOINT sp;
/ 时刻 4 /
/ other tables /

（Q1）确保隔离级别 设置RR

（Q2）启动事务 with consistent snapshot 可以得到一个一致性视图

（Q3）设置一个保存点 sp

（Q4）拿 t1 的表结构

（Q5）导数据

（Q6）

#### 表级锁

表锁一般是在数据库引擎不支持行锁时使用的，记得查看引擎

##### 表锁

lock tables ... read/write

通过unlock语句释放锁资源  或 客户端断连 时释放锁资源

限制了本线程的读写外 也限定了本线程的操作对象

锁表的开销依旧很大

##### 元数据锁 ( meta data lock, MDL )

5.5版本引入 

读锁：增删改查 	写锁：表结构更改

读锁之间不互斥 ： 可以有多个线程对同表增删改查

读写锁 写锁之间互斥 ：只能有一个线程修改表结构

※ 如何安全地给小表加字段

由于写锁有冲突 MDL锁在事务提交前不会释放 一旦读写锁锁死 开辟新的线程 数据库的线程就会爆满

① 解决正在执行的长事务 

information_schema 的 innodb_trx 表 暂停DDL 或 kill 掉长事务

（ kill 未必有用 新请求可能会迅速连接

② 在alter table 语句中设定等待时间，如果在等待时间中拿不到MDL写锁也不要阻塞后面的业务语句

alter table T NOWAIT ( WAIT N ) add column ...

#### 行锁

行锁在引擎层实现 InnoDb支持行锁 MyISAM 不支持

##### 两阶段锁

行锁在需要时加上 在事务结束（提交）时释放

=> 如果事务中需要锁多个行 要把最可能冲突的、影响并发度的锁后放

##### 死锁和死锁检测

不同的线程出现循环资源依赖 导致 线程均陷入无限等待 => 死锁

① 等待超时：设置参数 innodb_lock_wait_timeout 默认50s

太短的等待时间会干涉到正常的锁等待

② 死锁检测：参数innodb_deadlock_detect 设为on 死锁发现后回滚其中一个事务

热点行更新导致的性能问题（如1000条update更新同一行）

① 关闭死锁检测：直接降低百万量级的操作开销 但是可能会带来其他业务的超时 

② 控制并发度：控制在服务端或中间件（连接服务端的客户端会有很多）

即 对于进入引擎之前的同行操作进行排队 防止引擎内部发生大量的死锁检测

数据库结构不变的情况下的设计优化：

将一行的逻辑拆成多行 -> 根据实际业务变化



## 实践篇

### 01 | 普通索引和唯一索引













